package Submit;

###############################################################################
# Cleo / Linux
#
###############################################################################

require Exporter;
@ISA = qw(Exporter);

@EXPORT_OK = qw(submit);

use File::Path qw(mkpath);

use Reporting qw(debug_report failed_report ok_report start_report command_report);

# debug_report(string)  - Logs string as a debug message
# failed_report(string) - Sends a message to the NJS to say that execution of the command failed. 
#                         The string is sent to the NJS as part of the failure message. It is also logged
# ok_report(string)     - Sends a message to the NJS to say that execution of the command was successful.
#                         The string is also logged as a debug message.
# start_report          - Start of execution of a request from NJS, write to current output.
# command_report        - This is the command that was executed, report if debugging record for possible printing by a failed command.

use strict;

# Submit the script to the BSS

# arg 1 = The script (this is called because the script contains the string "#TSI_SUBMIT");
#
# Returns void to TSI
#         on success returns the BSS identifier assigned to the job
#         on fail return a message 
#

BEGIN 
{
    # --------------------------------------------------------------------
    # Create a file name to which scripts are written for the submits to
    # the batch sub-system. This needs to be unique as there may be
    # more than one TSI running, so base on the process id.
    
    $Submit::tsi_unique_file_name = "TSI_temp_file_$$";
    
    $Submit::pbs_submit_script = "tsi_submit_$$";
    
    # Always cd to some neutral place when not doing something
    $Submit::neutral_dir = $ENV{PWD};
    if($Submit::neutral_dir =~ m/(.*)/s) {
	$Submit::neutral_dir = $1;
    }
}

sub submit 
{
    my $from_njs = shift;
    
    # Correction for $HOME or $USER in root directories
    # Substitute for these values as the executed script's
    # environment will not (and if it did the values will
    # be wrong). This is safe as thes script seen here is
    # completely generated by the NJS and so we will not be
    # messing with any user created code.
    
    $from_njs =~ s/\$USER/$ENV{USER}/g;
    $from_njs =~ s/\$HOME/$ENV{HOME}/g;
    
    # Get the information from the NJS (embedded as comments)
    #
    # Not picking up defnitions of Software Resources sent as:
    # #TSI_SWR<name>
    
    # First clear all command line sections from previous iterations
    my $jobname =       ""; # the name that should be given to the job.
    my $outcome_dir =   ""; # the NJS expects that the stdout and stderr of the job are written to files named stdout and stderr in the directory named as the value of this field.
    my $uspace_dir =    ""; # the initial working directory of the script
    my $time =          ""; # the run time (wall clock) limit requested by this job in seconds
    my $memory =        ""; # the memory requirement of the job (in megabytes) [per processor/per node/per job -- see below]
    my $nodes =         ""; # the number of nodes required by this job. The value may be 0, then this is a non-parallel job, otherwise it has some parallel characteristic.
    my $processors =    ""; # the number of processors per node required by the job
    my $fast_fs =       ""; # the amount of storage to allocate on a fast temporary file system for this job (in megabytes). On the Uspace StorageServer
    my $large_fs =      ""; # the amount of storage to allocate on a large temporary file system for this job (in megabytes). On the Uspace StorageServer
    my $home_fast_fs =  ""; # the amount of storage to allocate on a fast temporary file system for this job (in megabytes). On the Home StorageServer
    my $home_large_fs = ""; # the amount of storage to allocate on a large temporary file system for this job (in megabytes). On the Home StorageServer
    my $queue =         ""; # the BSS queue to which this job should be submitted
    my $email =         ""; # the email address to which the BSS should send any status change emails.
    my $interactive =   ""; # the presence of this indicates that the task contained a SoftwareResource whose invocation definition in the IDB says that
                            #     it should be executed "interactively". The stdout and stderr files should be placed in the Outcome directory. However,
                            #     the TSI can reply with an OK and not the BSS id.

    $_ = $from_njs;
    while(/#TSI_(\S+) (.*)\n/g) {
        $jobname =       $2 if $1 eq "JOBNAME";
        $outcome_dir =   $2 if $1 eq "OUTCOME_DIR";
        $uspace_dir =    $2 if $1 eq "USPACE_DIR";
        $time =          $2 if $1 eq "TIME";
        $memory =        $2 if $1 eq "MEMORY";
        $nodes =         $2 if $1 eq "NODES";
        $processors =    $2 if $1 eq "PROCESSORS";
        $fast_fs =       $2 if $1 eq "FASTFS";
        $large_fs =      $2 if $1 eq "LARGEFS";
        $home_fast_fs =  $2 if $1 eq "HOMEFASTFS";
        $home_large_fs = $2 if $1 eq "HOMELARGEFS";
        $queue =         $2 if $1 eq "QUEUE";
        $email =         $2 if $1 eq "EMAIL";
        $interactive =   $2 if $1 eq "PREFER_INTERACTIVE";
    }

    if($interactive eq "true") 
    {
	start_report("Interactively executing a job");
    }
    else 
    {
	start_report("Submitting a job to the BSS");
    }
    
    my $resource_list = "";

    # Jobname
    #################################################################################
    # Jobname: not available under Cleo
    $jobname = "";

    # Queue 
    #################################################################################
    if ($queue eq "NONE") 
    {
	$queue = "main";
    }
    $resource_list = "$resource_list"." -q $queue";

    # Memory
    #################################################################################
    # Job memory requirements in megabytes, this can be
    # either for the whole job, for each processor or
    # for each node depending on how the IDB is set up
    # (see PER_xxxx_LIMITS)
    #
    # Memory: not available under Cleo
    $memory = "";

    # Nodes and Processors
    #################################################################################
    # $nodes is number of nodes required
    #
    # $processors (processors per node) is 1 if the system
    # is not an SMP
    #       
    # Nodes count, NONE implies serial, otherwise a valid number 
    #
    
    if($nodes eq "NONE") 
    {
        # Single node, single processor job
        $resource_list = "$resource_list"." -np $processors";
    }
    else 
    {
        # Multiple node and/or processors, always a value for $processors
	$nodes = $nodes * $processors;

        $resource_list = "$resource_list"." -np $nodes";
    }
     
    # Time 
    #################################################################################
    # Job time requirement. Wallclock time in seconds.
    $resource_list = "$resource_list"." -l $time";
    
    # Send email to user
    #################################################################################
    # Email: not available under Cleo
    $email = "";
    
    # Job output
    #################################################################################
    # Tell the BSS to put the batch job's stdout and stderr
    # into these files
    $resource_list = "$resource_list"." -stdout $outcome_dir/stdout";
    $resource_list = "$resource_list"." -stderr $outcome_dir/stderr";
    
    # cd to the Uspace directory, will write a file soon and
    # this means that there does not need to be a TSI working
    # directory
    if(chdir($uspace_dir) == 0) 
    {
	failed_report("Could not cd to Uspace $uspace_dir because $!");
	return 0;
    }
    
    # Make sure that the Outcome directory is there for the stdout and stderr files
    mkpath $outcome_dir, 0, 0700 unless -e $outcome_dir;
    chmod 0700, $outcome_dir;
    
    # Ignoring all other fields
    
    #####
    
    open(EMSCRIPT,">$Submit::tsi_unique_file_name");
    print EMSCRIPT $from_njs;
    close(EMSCRIPT);

    if ($interactive eq "true")
    {
	my $command = "$Submit::tsi_unique_file_name";
	chmod 0700, $command;
	command_report($command);
	`./$command > $outcome_dir/stdout 2> $outcome_dir/stderr`;

	ok_report();
    }
    else 
    {
	# Torque requires a full qualified path for the script which has to be executed
#	$resource_list = "$resource_list"."$uspace_dir"."/"."$Submit::tsi_unique_file_name";   

#	open(PBSSCRIPT,">$Submit::pbs_submit_script");
#	print PBSSCRIPT $resource_list;
#	close (PBSSCRIPT);

#	chmod 0700, $Submit::tsi_unique_file_name;
#	my $command = "$main::submit_cmd $Submit::pbs_submit_script";
	my $command = "$main::submit_cmd $resource_list $Submit::tsi_unique_file_name";
	
	command_report($command);
	
	# and execute the command
	my $output = `($command) 2>&1`;
	
	# Parse output
	if($? != 0)
	{
	    failed_report($output);
	}
	else
	{
	    # Succeeded, return Job Identifier
	    # looking for line "ID=XXX" (want the xxx)
	
	    if($output =~ /ID=([0-9])*/)
	    {
		my $jobid = "$queue.$1";
		
		# qsub does not report a failure code so we need to
		# check here that we got an integer. If we did assume
		# OK, otherwise report a failure
#		if (length($jobid) == 0)
#		{
		    debug_report("Job submitted OK. Identifier: $jobid");
		    print main::CMD_SOCK "$jobid\n";
#		}
#		else 
#		{
#		    failed_report("Job submit failed?: $jobid $output");
#		}
	    }
	    else 
	    {
		failed_report("Request id not found in: $output");
	    }
	}
    }
    chdir $Submit::neutral_dir;
}
